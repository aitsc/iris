import random
import math
import copy

class 标准BP神经网络:
    def __init__(self,输入数据向量,输出数据向量): #二维list
        self.输入数据向量=copy.deepcopy(输入数据向量)
        self.输出数据向量=copy.deepcopy(输出数据向量)
        if len(输入数据向量)!=len(输出数据向量): raise

    def 初始化BP参数(self,输入层神经元个数,隐层神经元个数,输出层神经元个数):
        self.输出层阈值=[self.随机函数() for i in range(输出层神经元个数)]
        self.隐层阈值=[self.随机函数() for i in range(隐层神经元个数)]
        #第一个list代表一个输出神经元对应所有隐神经元的连接权值
        self.输出层_隐层权值=[[self.随机函数() for j in range(隐层神经元个数)] for i in range(输出层神经元个数)]
        #第一个list代表一个隐神经元对应所有输入神经元的连接权值
        self.隐层_输入层权值=[[self.随机函数() for j in range(输入层神经元个数)] for i in range(隐层神经元个数)]

    def 开始训练(self,隐层神经元个数,训练轮数=1,累计误差最小值=1.0,学习率=0.1,初始化所有连接权和阈值=True):
        self.隐层神经元个数=隐层神经元个数
        self.学习率=学习率
        最后训练轮数=训练轮数
        # 在(0,1)范围内随机初始化网络中所有连接权和阈值
        if 初始化所有连接权和阈值:
            self.初始化BP参数(len(self.输入数据向量[0]),self.隐层神经元个数,len(self.输出数据向量[0]))
        累计误差 = -1
        for 轮数 in range(训练轮数):
            累计误差=0
            for 第i向量 in range(len(self.输入数据向量)):
                当前输入向量=self.输入数据向量[第i向量]
                # 根据当前参数和式(5.3)计算当前样本的输出
                (隐层输出向量, 输出层输出向量)=self.计算输出向量(当前输入向量,self.Sigmoid函数)
                累计误差+=self.计算均方误差(self.输出数据向量[第i向量],输出层输出向量)
                # 根据式(5.10)计算输出层神经元的梯度项
                g向量=self.计算输出层神经元的梯度项(self.输出数据向量[第i向量],输出层输出向量)
                # 根据式(5.15)计算隐层神经元的梯度项
                e向量=self.计算隐层神经元的梯度项(隐层输出向量,g向量)
                # 根据式(5.11)-(5.14)更新连接权、阈值
                    #更新 输出层_隐层权值
                for h in range(self.隐层神经元个数):
                    for j in range(len(self.输出层_隐层权值)):
                        self.输出层_隐层权值[j][h]+=self.学习率*g向量[j]*隐层输出向量[h]
                    #更新 输出层阈值
                for j in range(len(self.输出层_隐层权值)):
                    self.输出层阈值[j]+=-self.学习率*g向量[j]
                    #更新 隐层_输入层权值
                for h in range(self.隐层神经元个数):
                    for i in range(len(当前输入向量)):
                        self.隐层_输入层权值[h][i]+=self.学习率*e向量[h]*当前输入向量[i]
                    #更新 隐层阈值
                for h in range(self.隐层神经元个数):
                    self.隐层阈值[h]+=-self.学习率*e向量[h]
            累计误差=累计误差/len(self.输入数据向量)
            if 累计误差<=累计误差最小值:
                最后训练轮数=轮数+1
                break
        print('总训练轮数=%d,最后累计误差=%f'%(最后训练轮数,累计误差))

    def 预测输出向量(self,所有输入数据向量,二值化=False):
        if len(所有输入数据向量[0])!=len(self.输入数据向量[0]): raise  #保证维数相等
        输出数据向量=[]
        for i in 所有输入数据向量:
            输出数据向量.append(self.计算输出向量(i,self.Sigmoid函数)[1])
            if 二值化:
                for j in range(len(输出数据向量[-1])):
                    if 输出数据向量[-1][j]>0.5: 输出数据向量[-1][j]=1
                    else: 输出数据向量[-1][j]=0
        return 输出数据向量 #二维list

    def 随机函数(self):
        随机=random.randint(0,10000)/10000
        return 随机

    def Sigmoid函数(self,x):
        y=1/(1+pow(math.e,-x))
        return y

    def 计算输出向量(self,输入向量,激活函数):
        输出层输出向量=[]
        隐层输出向量=[]
        #输入层到隐层的计算
        for 权值向量 in self.隐层_输入层权值:
            一个隐层神经元输出=0
            for i in range(len(权值向量)):
                一个隐层神经元输出+=权值向量[i]*输入向量[i]
            一个隐层神经元输出=激活函数(一个隐层神经元输出-self.隐层阈值[self.隐层_输入层权值.index(权值向量)])
            隐层输出向量.append(一个隐层神经元输出)
        #隐层到输出层的计算
        for 权值向量 in self.输出层_隐层权值:
            一个输出层神经元输出=0
            for i in range(len(权值向量)):
                一个输出层神经元输出+=权值向量[i]*隐层输出向量[i]
            一个输出层神经元输出=激活函数(一个输出层神经元输出-self.输出层阈值[self.输出层_隐层权值.index(权值向量)])
            输出层输出向量.append(一个输出层神经元输出)
        return (隐层输出向量,输出层输出向量)

    def 计算均方误差(self,真输出向量,训练的输出向量):
        均方误差=0
        for i in range(len(真输出向量)):
            均方误差+=pow(真输出向量[i]-训练的输出向量[i],2)
        return 均方误差/2  #这里除以2是为了后续求导便利

    def 计算累计均方误差(self,所有真输出向量,所有预测的输出向量):
        累计均方误差=0
        for i in range(len(所有真输出向量)):
            累计均方误差+=self.计算均方误差(所有真输出向量[i],所有预测的输出向量[i])
        return 累计均方误差/len(所有真输出向量)

    def 计算累计正确率(self,所有真输出向量,所有预测的输出向量,向量正对化=False):  #向量正对化=True 代表一个向量只有正对2种可能,反之指一个向量中的每个值都有正对2种可能
        累计正确率=0
        for i in range(len(所有真输出向量)):
            相等个数=0
            for j in range(len(所有真输出向量[i])):
                if 所有真输出向量[i][j]==所有预测的输出向量[i][j]:
                    相等个数+=1
            if 向量正对化:
                if 相等个数==len(所有真输出向量[0]):
                    累计正确率+=1
            else:
                累计正确率+=相等个数/len(所有真输出向量[0])
        return 累计正确率/len(所有真输出向量)

    def 计算输出层神经元的梯度项(self,真输出向量,训练的输出向量):
        g向量=[0 for i in range(len(真输出向量))]
        for i in range(len(真输出向量)):
            g向量[i]=训练的输出向量[i]*(1-训练的输出向量[i])*(真输出向量[i]-训练的输出向量[i])
        return g向量

    def 计算隐层神经元的梯度项(self,隐层输出向量,输出层神经元的梯度项向量):
        e向量=[0 for i in range(len(隐层输出向量))]
        for i in range(len(隐层输出向量)):
            w乘g=0
            for j in range(len(输出层神经元的梯度项向量)):
                w乘g+=self.输出层_隐层权值[j][i]*输出层神经元的梯度项向量[j]
            e向量[i]=隐层输出向量[i]*(1-隐层输出向量[i])*w乘g
        return e向量

def 读取数据集(数据集地址,输入神经元个数,不要的列=[],取行的范围=[0,0],数据从几行开始=0,数据分隔符=','):
    所有输入向量=[]
    所有输出向量=[]
    读取=open(数据集地址,'r',encoding='utf-8')
    原始数据=读取.readlines()
    读取.close()
    第几个=数据从几行开始
    if 取行的范围[0]<=0:
        取行的范围[0]=第几个
        取行的范围[1]=len(原始数据)
    while True:
        if len(原始数据)<=第几个 or 取行的范围[1]<第几个: break
        一行数据 = 原始数据[第几个]
        第几个+=1
        if 取行的范围[0]>=第几个: continue
        一行数据=一行数据.strip().split(数据分隔符)
        if len(一行数据) == 0: continue  #此行无值
        所有输入向量.append([float(一行数据[i]) for i in range(0,输入神经元个数+len(不要的列)) if i not in 不要的列])
        所有输出向量.append([float(一行数据[i]) for i in range(输入神经元个数+len(不要的列),len(一行数据)) if i not in 不要的列])
    return (所有输入向量,所有输出向量)

# (所有输入向量,所有输出向量)=读取数据集('t.txt',2,[],[0,200])
# print(所有输入向量)
# print(所有输出向量)
# 职位预测BP=标准BP神经网络(所有输入向量,所有输出向量)
#
# 职位预测BP.开始训练(隐层神经元个数=2,训练轮数=50,累计误差最小值=0.001,学习率=1,初始化所有连接权和阈值=True)
# 预测输出向量=职位预测BP.预测输出向量(所有输入向量,二值化=True)
# print(预测输出向量)
# 累计正确率=职位预测BP.计算累计正确率(所有输出向量,预测输出向量,向量正对化=True)
# print('累计正确率=%f'%累计正确率)
# 计算累计均方误差=职位预测BP.计算累计均方误差(所有输出向量,预测输出向量)
# print('计算累计均方误差=%f'%计算累计均方误差)

(训练集输入向量,训练集输出向量)=读取数据集(数据集地址=r'D:\data\code\vscode\irisDataExperiment/vector and norm/trainSet.txt',
                        输入神经元个数=4,不要的列=[],取行的范围=[0,0],数据从几行开始=0,数据分隔符=',')
(测试集输入向量,测试集输出向量)=读取数据集(数据集地址=r'D:\data\code\vscode\irisDataExperiment/vector and norm/testSet.txt',
                        输入神经元个数=4,不要的列=[],取行的范围=[0,0],数据从几行开始=0,数据分隔符=',')

iris预测=标准BP神经网络(训练集输入向量,训练集输出向量)
iris预测.开始训练(隐层神经元个数=3,训练轮数=110,累计误差最小值=0.001,学习率=1,初始化所有连接权和阈值=True)

预测输出向量=iris预测.预测输出向量(测试集输入向量,二值化=True)
累计正确率=iris预测.计算累计正确率(测试集输出向量,预测输出向量,向量正对化=True)
计算累计均方误差=iris预测.计算累计均方误差(测试集输出向量,预测输出向量)

print('累计正确率=%f'%累计正确率)
print('计算累计均方误差=%f'%计算累计均方误差)